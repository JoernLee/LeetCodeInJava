package 排序;

import java.util.Arrays;

public class HeapSort {
	
	/**
	 * 1.堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。 
	 * 
	 * 2.堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。
	 * 此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。 
	 * 
	 * 3.两个关键问题：将一个无序序列构成一个堆；输出堆顶元素后，调整剩余元素成为一个新堆。
	 * 
	 * 4.总体来说，堆排序的时间复杂度为O(nlogn)，由于堆排序对原始记录的状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O(nlogn)。
	 * 
	 * 5.另外，由于出事构建堆所需要的比较次数比较多，因此，他并不适合待排序序列个数较少的情况。
	 * 
	 * 6.排序的运行时间主要耗费在初始构建堆和在重建堆时反复筛选上。在构建对的过程中，因为我们是完全二叉树从最下层最右边的非终端节点开始构建，将它与其孩子进行比较和若有必要的互换，对每个非终端节点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度为O(n)。 
		在正式排序时，第i次取堆顶记录重建堆需要用O(logi)的时间（完全二叉树的某个节点到根节点的距离为这里写图片描述），并且需要取n-1次堆顶记录，因此，重建堆的时间复杂度为O(nlogn)。 
	 * @param arr
	 */
	
	public void heapSort(int[] arr) {  
		  
	    // 循环建立初始堆  
		//为什么是length/2---在构建对的过程中，因为我们是完全二叉树从最下层最右边的非终端节点开始构建，将它与其孩子进行比较和若有必要的互换，对每个非终端节点来说，其实最多进行两次比较和互换操作（操作的是非终端节点）
	    for (int i = arr.length / 2; i >= 0; i--) {  
	  
	        HeapAdjust(arr, i, arr.length );  
	  
	    }  
	    // 进行n-1次循环，完成排序  
	    for (int i = arr.length - 1; i > 0; i--) {  
	  
	        // 最后一个元素和第一元素进行交换  
	        int temp = arr[i];  
	  
	        arr[i] = arr[0];  
	  
	        arr[0] = temp;  
	        
	        // 筛选 R[0] 结点，得到i-1个结点的堆  
	        HeapAdjust(arr, 0, i);  
	        
	        System.out.format("第 %d 趟: ", arr.length - i);  
	        System.out.println(Arrays.toString(arr));
	        
	        
	    }  

}
	/**
     * 构建大顶堆
     */
	private void HeapAdjust(int[] arr, int parent, int length) {
		int temp = arr[parent]; // temp保存当前父节点  
		  
	    int child = 2 * parent + 1; // 先获得左孩子  (是二叉树计算左孩子下标的方式)
	  
	   
	    //迭代来保证大顶堆的性质，如果儿子节点>父节点，节点交换---可能儿子的儿子节点和交换过去的父节点还是不满足最大堆性质---继续交换
	    //在初始化大顶堆的时候，需要操作length/2,来保证整个堆都满足了大顶堆的性质
	    while (child < length) {  
	  
	        // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点  
	  
	        if (child + 1 < length && arr[child] < arr[child + 1]) {  
	  
	            child++;  //++代表当前下标从左孩子移到了右孩子
	  
	        }  
	  
	   
	  
	        // 如果父结点的值已经大于孩子结点的值，则直接结束  
	  
	        if (temp >= arr[child])  
	  
	            break;  
	  
	   
	  
	        // 否则，把孩子结点的值赋给父结点  
	  
	        arr[parent] = arr[child];  
	  
	   
	  
	        // 选取孩子结点的左孩子结点,继续向下筛选  
	  
	        parent = child;  
	  
	        child = 2 * child + 1;  
	  
	    }  
	  
	    arr[parent] = temp;  
		
	}
}
